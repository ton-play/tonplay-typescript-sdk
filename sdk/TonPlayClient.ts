import { AccountResponseDTO, ApiException, AssetDeployResponseDTO, AssetType, BurnAssetRequestDTO, BuyItemRequestDTO, CancelItemRequestDTO, CheckTokenResponseDTO, CreateCollectionRequestDTO, CreateSingleItemRequestDTO, DeeplinkResponseDTO, ErrorResponse, GameWithdrawalRequestDTO, GateUserResponseDTO, ItemForSaleResponseDTO, MintNewCollectableRequestDTO, MintNewSftTokenRequestDTO, PageableImplAssetDTO, PageableImplAssetLiteDTO, SaleItemRequestDTO, TransferAssetRequestDTO } from './Models';

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TonPlayClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    private xAuthTonplay: string;
    private gameKey: string;

    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };

    /**
     * @param tonplayToken API token that you will receive after project registration
    **/
    constructor(tonplayToken: string) {
        this.http = { fetch: (url, init) => fetch(url, init) };// http ? http : window as any;
        this.baseUrl = "https://external.api.tonplay.io"; //baseUrl !== undefined && baseUrl !== null ? baseUrl : 

        this.xAuthTonplay = tonplayToken;
        this.gameKey = tonplayToken.split(':')[0];
    }

    protected prepareOptions(content?: string, method?: string): RequestInit {
        return {
            body: content,
            method: method ?? "GET",
            headers: {
                "X-Auth-Tonplay": this.xAuthTonplay !== undefined && this.xAuthTonplay !== null ? "" + this.xAuthTonplay : "",
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };
    }
    protected prepareGet(content?: string): RequestInit {
        return this.prepareOptions(content);
    }
    protected preparePut(content?: string): RequestInit {
        return this.prepareOptions(content, "PUT");
    }
    protected preparePost(content?: string): RequestInit {
        return this.prepareOptions(content, "POST");
    }
    protected prepareDelete(content?: string): RequestInit {
        return this.prepareOptions(content, "DELETE");
    }

    private parseError(responseText: string) {
        let resultError: any = null;
        let resultDataError = responseText === "" ? null : JSON.parse(responseText, this.jsonParseReviver);
        resultError = ErrorResponse.fromJS(resultDataError);
        return resultError;
    }

    private getArrayParser<T>(objectParser: (i: any) => T) {
        return (input: any) => {
            let result: T[];
            if (Array.isArray(input)) {
                result = [] as T[];
                for (let item of input)
                    result.push(objectParser(item));
            } else {
                result = <any>null;
            }

            return result;
        }
    }

    private stringParser(input: any) {
        return input !== undefined ? input : <any>null;
    }

    private voidParser(input: any) {
        return;
    }

    protected processResponse<T>(response: Response, objectParser: (input: any) => T): Promise<T> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => _headers[k] = v);
        };
        if (status === 403) {
            return response.text().then(_responseText => throwException("Forbidden", status, _responseText, _headers, this.parseError(_responseText)));
        } else if (status === 503) {
            return response.text().then(_responseText => throwException("Service Unavailable", status, _responseText, _headers, this.parseError(_responseText)));
        } else if (status === 400) {
            return response.text().then(_responseText => throwException("Bad Request", status, _responseText, _headers, this.parseError(_responseText)));
        } else if (status === 404) {
            return response.text().then(_responseText => throwException("Not Found", status, _responseText, _headers, this.parseError(_responseText)));
        } else if (status === 200) {
            return response.text().then(_responseText => objectParser(_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver)));
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => throwException("An unexpected server error occurred.", status, _responseText, _headers));
        }
        return Promise.resolve<T>(null as any);
    }

    /**
     * Validate JWT token
     * @param token - jwt to verify 
     * @returns [{ active, valid, userUid }]
     */
    checkToken(token: string): Promise<CheckTokenResponseDTO> {
        let url_ = this.baseUrl + "/x/auth/v1/check?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost())
            .then((_response: Response) => this.processResponse(_response, CheckTokenResponseDTO.fromJS));
    }

    /**
     * Put asset on sale
     * @param body - jwt to verify 
     * @return OK
     */
    putOnSale(body: SaleItemRequestDTO): Promise<DeeplinkResponseDTO> {
        let url_ = this.baseUrl + "/x/market/v1/sale";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePut(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, DeeplinkResponseDTO.fromJS));
    }

    /**
     * Buy asset
     * @return OK
     */
    buy(body: BuyItemRequestDTO): Promise<DeeplinkResponseDTO> {
        let url_ = this.baseUrl + "/x/market/v1/sale";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, DeeplinkResponseDTO.fromJS));
    }

    /**
     * Remove asset from sale
     * @return OK
     */
    saleCancel(body: CancelItemRequestDTO): Promise<DeeplinkResponseDTO> {
        let url_ = this.baseUrl + "/x/market/v1/sale";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareDelete(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, DeeplinkResponseDTO.fromJS));
    }

    /**
     * Generate link to transfer any asset
     * @return OK
     */
    transferAsset(address: string, type: AssetType, body: TransferAssetRequestDTO): Promise<string> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/transfer/{address}?";
        if (address === undefined || address === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + address));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, this.stringParser));
    }

    /**
     * Generate link to mint new SFTokens
     * @return OK
     */
    mintSftTokens(minterAddress: string, body: MintNewSftTokenRequestDTO): Promise<string> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/mint/sft/{address}";
        if (minterAddress === undefined || minterAddress === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + minterAddress));

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, this.stringParser));
    }

    /**
     * Generate link to mint new collectable item
     * @return OK
     */
    mintNewCollectableItem(collectionAddress: string, type: AssetType, body: MintNewCollectableRequestDTO): Promise<AssetDeployResponseDTO> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/mint/collection/{address}?";
        if (collectionAddress === undefined || collectionAddress === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + collectionAddress));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, AssetDeployResponseDTO.fromJS));
    }

    /**
     * Generate link to deploy single NFT or SFT
     * @return OK
     */
    deploySingle(type: AssetType, body: CreateSingleItemRequestDTO): Promise<AssetDeployResponseDTO> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/deploy/single?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, AssetDeployResponseDTO.fromJS));
    }

    /**
     * Generate link to deploy NFT or SFT collection
     * @return OK
     */
    deployCollection(type: AssetType, body: CreateCollectionRequestDTO): Promise<AssetDeployResponseDTO> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/deploy/collection?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, AssetDeployResponseDTO.fromJS));
    }

    /**
     * Withdrawal
     * @return OK
     */
    withdraw(body: GameWithdrawalRequestDTO): Promise<void> {
        let url_ = this.baseUrl + "/x/gamecenter/v1/withdraw";

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.preparePost(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, this.voidParser));
    }

    /**
     * Get all assets belong to user's account
     * @param userAddress user's wallet address
     * @param page (optional) Zero-based page index (0..N)
     * @param size (optional) The size of the page to be returned
     * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @return OK
     */
    getAllAccountsAssetsV2(userAddress: string, page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): Promise<PageableImplAssetLiteDTO> {
        let url_ = this.baseUrl + "/x/tondata/v2/assets/{address}?";
        if (userAddress === undefined || userAddress === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + userAddress));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, PageableImplAssetLiteDTO.fromJS));
    }

    /**
     * Get information about contract
     * @return OK
     */
    getContractState(address: string): Promise<AccountResponseDTO> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/{address}/status";
        if (address === undefined || address === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + address));

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, AccountResponseDTO.fromJS));
    }

    /**
     * Get NFT owner
     * @return OK
     */
    checkNftOwner(nftAddress: string): Promise<string> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/{address}/owner";
        if (nftAddress === undefined || nftAddress === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + nftAddress));


        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, this.stringParser));
    }

    /**
     * Get all assets related to game (for sale)
     * @param page (optional) Zero-based page index (0..N)
     * @param size (optional) The size of the page to be returned
     * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @return OK
     */
    getAllGameAssets(page?: number | undefined, size?: number | undefined, sort?: string[] | undefined): Promise<PageableImplAssetDTO> {
        let url_ = this.baseUrl + "/x/tondata/v1/assets/game?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, PageableImplAssetDTO.fromJS));
    }

    /**
     * Get same SFT assets on sale by address
     * @return OK
     */
    getSameOnSale(itemAddress: string): Promise<ItemForSaleResponseDTO[]> {
        let url_ = this.baseUrl + "/x/market/v1/item/{itemAddress}";
        if (itemAddress === undefined || itemAddress === null)
            throw new Error("The parameter 'itemAddress' must be defined.");
        url_ = url_.replace("{itemAddress}", encodeURIComponent("" + itemAddress));


        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, this.getArrayParser(ItemForSaleResponseDTO.fromJS)));
    }

    /**
     * Get assets on sale by game
     * @return OK
     */
    getSalesByGame(gameKey?: string): Promise<ItemForSaleResponseDTO[]> {
        let url_ = this.baseUrl + "/x/market/v1/game/{gameKey}";
        gameKey = gameKey ?? this.gameKey;
        if (gameKey === undefined || gameKey === null)
            throw new Error("The parameter 'gameKey' must be defined.");
        url_ = url_.replace("{gameKey}", encodeURIComponent("" + gameKey));

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, this.getArrayParser(ItemForSaleResponseDTO.fromJS)));
    }

    /**
     * Get all users by identifiers
     * @param identifiers (optional) 
     * @return OK
     */
    getUsersByIdentifiers(identifiers?: string[] | undefined): Promise<GateUserResponseDTO[]> {
        let url_ = this.baseUrl + "/x/auth/v1/user?";
        if (identifiers === null)
            throw new Error("The parameter 'identifiers' cannot be null.");
        else if (identifiers !== undefined)
            identifiers && identifiers.forEach(item => { url_ += "identifiers=" + encodeURIComponent("" + item) + "&"; });

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, this.getArrayParser(GateUserResponseDTO.fromJS)));
    }

    /**
     * Get user by identifier
     * @return OK
     */
    getUserByIdentifier(identifier: string): Promise<GateUserResponseDTO> {
        let url_ = this.baseUrl + "/x/auth/v1/user/{identifier}";
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier));

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareGet())
            .then((_response: Response) => this.processResponse(_response, GateUserResponseDTO.fromJS));
    }

    /**
     * Burn selected asset
     * @return OK
     */
    burn(address: string, body: BurnAssetRequestDTO): Promise<string> {
        let url_ = this.baseUrl + "/x/tondata/v1/ton/burn/{address}";
        if (address === undefined || address === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + address));

        return this.http.fetch(url_.replace(/[?&]$/, ""), this.prepareDelete(JSON.stringify(body)))
            .then((_response: Response) => this.processResponse(_response, this.stringParser));
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}